{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"All Workshops","text":"<p>All Workshops</p>"},{"location":"trajectoryAnalysis/00_background/","title":"Introduction To Trajectory Analysis","text":""},{"location":"trajectoryAnalysis/00_background/#test-branch-introduction-to-trajectory-analysis","title":"TEST BRANCH - Introduction To Trajectory Analysis","text":"<p>Content developed by Data Intensive Studies Center &amp; TTS Research Technology at Tufts University</p> <ul> <li>Rebecca Batorsky, PhD, Data Scientist I 1</li> <li>Albert Tai, PhD, Research Assistant Professor3 </li> <li>Jason Laird, MSc, Bioinformatics Scientist2</li> </ul> <ol> <li>Data Intensive Study Center, Tufts University</li> <li>Research Technology, Tufts Technology Services, Tufts University</li> <li>Immunology, Tufts School of Medicine</li> </ol>"},{"location":"trajectoryAnalysis/00_background/#schedule","title":"Schedule","text":"<p>Lecture</p> <ol> <li>Introduction to Single cell RNA-Seq</li> <li>Introduction to Trajectory Analysis</li> </ol> <p>Hands On Activity</p> <ol> <li>Setup and Monocle3 Objects </li> <li>Monocle Workflow and Trajectory Analysis</li> <li>Pseudotime and Differential Expression</li> </ol>"},{"location":"trajectoryAnalysis/01_setup_and_monocle/","title":"Setup and Monocle3 Objects","text":"<p>Prerequisites</p> <ul> <li>Request an account on the Tufts HPC Cluster<ul> <li>Note if you signed up for the Introduction to Single-Cell RNA-Seq Time Series and Trajectory Analysis workshop this will have been already taken care of for you!</li> </ul> </li> <li>Connect to the VPN if off campus</li> </ul>"},{"location":"trajectoryAnalysis/01_setup_and_monocle/#navigate-to-the-cluster","title":"Navigate To The Cluster","text":"<p>Once you have an account and are connected to the VPN/Tufts Network, navigate to the OnDemand Website and log in with your tufts credentials. Once you are logged in you'll notice a few navigation options:</p> <p>OnDemand Layout</p> <p></p> <p>Click on <code>Interactive Apps &gt; RStudio Pax</code> and you will see a form to fill out to request compute resources to use RStudio on the Tufts HPC cluster. We will fill out the form with the following entries:</p> <ul> <li><code>Number of hours</code> : <code>5</code></li> <li><code>Number of cores</code> : <code>1</code></li> <li><code>Amount of memory</code> : <code>16GB</code></li> <li><code>R version</code> : <code>4.0.0</code></li> <li><code>Reservation for class, training, workshop</code> : <code>Bioinformatics Workshops</code><ul> <li>NOTE: This reservation closed on April 26th 2023, use <code>Default</code> if running through the materials after that date.</li> </ul> </li> <li><code>Load Supporting Modules</code>: <code>boost/1.63.0-python3 java/1.8.0_60 gsl/2.6</code></li> </ul> <p>Click <code>Launch</code> and wait until your session is ready. Click <code>Connect To RStudio Server</code>, and you will notice a new window will pop up with RStudio. </p> Are you connected to RStudio? <ul> <li>Yes (put up a green check mark in zoom)</li> <li>No (raise hand in zoom)</li> </ul>"},{"location":"trajectoryAnalysis/01_setup_and_monocle/#data-scripts","title":"Data &amp; Scripts","text":"<p>To copy over the data and scripts we will need for the workshop into our home directory, enter the following command into the console:</p> <pre><code>file.copy(from=\"/cluster/tufts/bio/tools/training/trajectory_analysis\",to=\"~/\", recursive = TRUE)\n</code></pre>"},{"location":"trajectoryAnalysis/01_setup_and_monocle/#project-setup","title":"Project Setup","text":"<p>Now we are going to use this folder to create a new R project. R projects are great for managing analyses in a portable, self-contained folder. To create an R project from within our <code>trajectory_analysis</code> directory we will:</p> <ul> <li>Go to <code>File</code> &gt; <code>New Project</code></li> <li><code>Existing Directory</code></li> <li>Browse for the <code>trajectory_analysis</code> folder</li> <li>Click <code>Create Project</code></li> </ul> <p>Let's navigate to our project in our home directory and open up our workshop script:</p> <ul> <li>Click on the <code>Files</code> tab in the lower right hand Rstudio pane</li> <li>Click on the <code>scripts</code> folder</li> <li>Click on the <code>trajectory_analysis.Rmd</code> script</li> </ul>"},{"location":"trajectoryAnalysis/01_setup_and_monocle/#todays-data","title":"Today's Data","text":"<p>Today we will be working with data from  Paulson et al. 2022 which found cell-type-specific neurodevelopmental abnormalities that were shared across ASD risk genes. To this end they leveraged organoid single-cell RNA-seq data to investigate these abnormalities:</p> <p>Paulson et al. 2022</p> <p></p>"},{"location":"trajectoryAnalysis/01_setup_and_monocle/#monocle3-cell-data-objects","title":"Monocle3 Cell Data Objects","text":"<ul> <li>We will be working with single-cell RNA-seq data in R today. Today, we will be performing trajectory analysis using the R package Monocle3. Monocle3 stores single-cell RNA-seq data as a cell data set object, which has the following structure:</li> </ul> <p>Monocle3's Cell Data Set Object</p> <p></p>"},{"location":"trajectoryAnalysis/01_setup_and_monocle/#loading-libraries-and-data","title":"Loading Libraries and Data","text":"<p>Before we analyze our single-cell RNA-Seq data we will need to load the libraries needed for our analysis:</p> <pre><code># set the libPath and load the libraries\nLIB='/cluster/tufts/hpc/tools/R/4.0.0/'\n.libPaths(c(\"\",LIB))\nlibrary(monocle3)\nlibrary(tidyverse)\n</code></pre> <ul> <li>Let's start by loading the input matrices we need to create our cell data set object!</li> </ul> <pre><code># read in cells by gene count matrix\ncounts &lt;- read.csv(\"/cluster/tufts/bio/data/projects/2023_02_time_series_scrnaseq/rds/SUV420H1_Mito210_d35_counts.csv\", row.names=1,\ncheck.names = F)\n\nhead(counts)\n</code></pre> <p>output</p> <pre><code>              1_AAAGGTACACAGCTGC 1_AAAGGTATCTGCCTGT 1_AACAACCCACACTGGC\nFO538757.2                     0                  1                  0\nAP006222.2                     0                  0                  0\nRP11-206L10.9                  0                  0                  0\nLINC00115                      0                  0                  0\n</code></pre> <pre><code># read in sample meta data\nmeta &lt;- read.csv( \"/cluster/tufts/bio/data/projects/2023_02_time_series_scrnaseq/rds/SUV420H1_Mito210_d35_meta.csv\", row.names=1)\n\nhead(meta)\n</code></pre> <p>output</p> <pre><code>                   treat         dataset            CellType\n1_AAAGGTACACAGCTGC    wt SUV_Mito210_d35 Cycling Progenitors\n1_AAAGGTATCTGCCTGT    wt SUV_Mito210_d35                 aRG\n1_AACAACCCACACTGGC    wt SUV_Mito210_d35 Cycling Progenitors\n1_AACAAGATCGAAGCAG    wt SUV_Mito210_d35                 aRG\n1_AACAGGGAGGACAGCT    wt SUV_Mito210_d35                 aRG\n1_AACCTGAGTATACGGG    wt SUV_Mito210_d35 Cycling Progenitors\n</code></pre> <pre><code># can optionally list more annotation of genes\ngene_meta &lt;- read.csv(\"/cluster/tufts/bio/data/projects/2023_02_time_series_scrnaseq/rds/SUV420H1_Mito210_d35_genemeta.csv\",\nrow.names=1)\nhead(gene_meta)\n</code></pre> <p>output</p> <pre><code>              gene_short_name\nFO538757.2         FO538757.2\nAP006222.2         AP006222.2\nRP11-206L10.9   RP11-206L10.9\nLINC00115           LINC00115\nFAM41C                 FAM41C\nRP11-54O7.1       RP11-54O7.1\n</code></pre> <ul> <li>Now that we have loaded our gene expression matrix, our meta data, and our gene metadata, we can use these to create the cell data set object!</li> </ul> <pre><code># note the colnames(counts) must match rownames(meta)\n\ncds &lt;- new_cell_data_set(expression_data = as.matrix(counts),\ncell_metadata = meta, gene_metadata = gene_meta)\n\n# let's take a look at our new object!\ncds\n</code></pre> <p>output</p> <pre><code>class: cell_data_set \ndim: 12962 4000 \nmetadata(1): cds_version\nassays(1): counts\nrownames(12962): FO538757.2 AP006222.2 ... AC004556.1 AC240274.1\nrowData names(0):\ncolnames(4000): 1_AAAGGTACACAGCTGC 1_AAAGGTATCTGCCTGT ... 6_TTTGACTGTACCATAC 6_TTTGGTTGTTACGTAC\ncolData names(4): treat dataset CellType Size_Factor\nreducedDimNames(0):\naltExpNames(0):\n</code></pre> <ul> <li>Here we will highlight that we have 12962 rows and 4000 columns, our rownames are gene names, our column names are the cell names, we have one assay (<code>counts</code>), we have 4 columns of meta data under <code>colData</code>, and we have no dimension reductions under <code>reducedDimNames</code>.</li> <li>Let's investage a few helpful functions that can help access these data:</li> </ul> <pre><code># access the gene names\nrownames(cds)[1:5]\n</code></pre> <p>output</p> <pre><code>[1] \"FO538757.2\"    \"AP006222.2\"    \"RP11-206L10.9\" \"LINC00115\"     \"FAM41C\" </code></pre> <pre><code># access the cell names\ncolnames(cds)[1:5]\n</code></pre> <p>output</p> <pre><code>[1] \"1_AAAGGTACACAGCTGC\" \"1_AAAGGTATCTGCCTGT\" \"1_AACAACCCACACTGGC\" \"1_AACAAGATCGAAGCAG\" \"1_AACAGGGAGGACAGCT\"\n</code></pre> <pre><code># access the feature data\nhead(rowData(cds))\n</code></pre> <p>output (Notice we have no gene meta data)</p> <pre><code>DataFrame with 6 rows and 0 columns\n</code></pre> <pre><code># access the meta data\nhead(colData(cds))\n</code></pre> <p>output</p> <pre><code>DataFrame with 6 rows and 4 columns\ntreat         dataset            CellType Size_Factor\n&lt;character&gt;     &lt;character&gt;         &lt;character&gt;   &lt;numeric&gt;\n1_AAAGGTACACAGCTGC          wt SUV_Mito210_d35 Cycling Progenitors    1.074965\n1_AAAGGTATCTGCCTGT          wt SUV_Mito210_d35                 aRG    0.584379\n1_AACAACCCACACTGGC          wt SUV_Mito210_d35 Cycling Progenitors    1.248093\n1_AACAAGATCGAAGCAG          wt SUV_Mito210_d35                 aRG    1.115985\n1_AACAGGGAGGACAGCT          wt SUV_Mito210_d35                 aRG    0.682049\n1_AACCTGAGTATACGGG          wt SUV_Mito210_d35 Cycling Progenitors    0.997981\n</code></pre> <pre><code># access the assay data\nhead(assay(cds)[,1:3])\n</code></pre> <p>output</p> <pre><code>6 x 3 sparse Matrix of class \"dgCMatrix\"\n1_AAAGGTACACAGCTGC 1_AAAGGTATCTGCCTGT 1_AACAACCCACACTGGC\nFO538757.2                     .                  1                  .\nAP006222.2                     .                  .                  .\nRP11-206L10.9                  .                  .                  .\nLINC00115                      .                  .                  .\nFAM41C                         .                  .                  .\nRP11-54O7.1                    .                  .                  .\n</code></pre> What is a dgCMatrix? <p>a dgCMatrix is a type of sparse, compressed, column-oriented numeric matrix where non-zero elements in each column are sorted into increasing row order. Essentially, this is a way of storing matrices with less memory which is important for single-cell RNA-seq data given so many matrices are generated.</p>"},{"location":"trajectoryAnalysis/02_monocle_setup_and_trajectory_analysis/","title":"Monocle3 Workflow and Trajectory Analysis","text":""},{"location":"trajectoryAnalysis/02_monocle_setup_and_trajectory_analysis/#running-monocle3","title":"Running Monocle3","text":"<p>There are typically four main commands when running Monocle3:</p> <p>Monocle3 Workflow</p> <p></p> <ul> <li><code>preprocess_cds()</code>: normalizes the data by log and size factor to address depth differences and calculates a lower dimensional space that will be used as the input for further dimensionality reduction like tSNE and UMAP.</li> </ul> <code>preprocess_cds()</code> options <ul> <li><code>method</code> : initial method of dimention reduction - options are  \"PCA\" and \"LSI\"</li> <li><code>num_dim</code> : the dimensionality of the reduced space - default is 50</li> <li><code>norm_method</code> : methods of normalizing the expression data - options are \"log\", \"size_only\", \"none\"</li> <li><code>use_genes</code> : when this option is not NULL, only the list of genes provided will be used for dimension reduction - default is NULL</li> <li><code>pseudo_count</code> : amount to increase expression values before normalization and dimensionality reduction. If the value is NULL a pseudo count of 1 is added - default is NULL</li> <li><code>scaling</code> : this will scale each gene before running trajectory reconstruction if set to TRUE - default is TRUE</li> </ul> <ul> <li><code>reduce_dimension()</code>: reduces the dimensionality of the data using algorithms like UMAP or tSNE. Trajectories will be calculated through this space.</li> </ul> <code>reduce_dimension()</code> options <ul> <li><code>max_components</code> : the dimensionality of the reduced space - default is 2</li> <li><code>reduction_method</code> : the method used for dimension reduction - options are \"UMAP\", \"tSNE\", \"PCA\", \"LSI\", and \"Aligned\"</li> <li><code>preprocess_method</code> : what preprocess method was used to initially reduce the dimensionality of the gene expression data - default is LSI</li> <li><code>umap.metric</code> : the distance metrice used when calculating the UMAP - default is \"cosine\"</li> <li><code>umap.min_dist</code> : the minimum distance to be input into the UMAP function - default is 0.1</li> <li><code>umap.n_neighbors</code> : the number of neighbors to use during kNN graph construction - default is 15L</li> <li><code>umap.fast_sgd</code> : option to use Stochastic Gradient Descent when caclulating the UMAP to speed up the computation - default is FALSE</li> <li><code>umap.nn_method</code> : the nearest neighbor method to be used by UMAP - default is \"annoy\"</li> </ul> <ul> <li><code>cluster_cells()</code>: clusters the cells using Louvain/Leiden community detection, and returns a cell_data_set with internally stored cluster assignments. These cluster assignments can then be assigned to cell types given that cells in a cluster are likely to be the same cell type as cells of the same type have similar gene expression patterns.</li> </ul> <code>cluster_cells()</code> options <ul> <li><code>reduction_method</code> : The dimensionality reduction method upon which to base clustering - options are \"UMAP\", \"tSNE\", \"PCA\", \"LSI\", and \"Aligned\"</li> <li>k : the number of nearest neighbors to use when creating the k nearest neighbor graph for Louvain/Leiden clustering. k is related to the resolution of the clustering result, a bigger k will result in lower resolution and vice versa - default is 20</li> <li><code>cluster_method</code> :  the clustering method to use, if \"louvain\" is used the resolution paramter is ignored - default is \"leiden\" </li> <li><code>num_iter</code> : number of iterations used for Louvain/Leiden clustering - defualt is 2</li> <li><code>partition_qval</code> : q-value cutoff to determine when to partition - default is 0.05</li> <li><code>weight</code> : to determine whether or not to use Jaccard coefficients for two nearest neighbors (based on the overlapping of their kNN) as the weight used for Louvain clustering - default is FALSE</li> <li><code>resolution</code> : controls the resolution of clustering. If NULL, the parameter is determined automatically - default is NULL</li> <li><code>random_seed</code> : used by the random number generator in louvain-igraph package. This argument will be ignored if num_iter is larger than 1 - default is NULL</li> </ul> <ul> <li><code>learn_graph()</code>: constructs the trajectory through clusters in a lower dimensional space to \"learn the sequence of gene expression changes each cell must go through as part of a dynamic biological process\"</li> </ul> <code>learn_graph()</code> options <ul> <li><code>use_partition</code> : determines whether to use partitions calculated during cluster_cells and therefore to learn disjoint graph in each partition. When use_partition = FALSE, a single graph is learned across all partitions - default is TRUE</li> <li><code>close_loop</code> : determines whether or not to perform an additional run of loop closing after estimating the principal graphs to identify potential loop structure in the data space - default is TRUE</li> <li><code>learn_graph_control</code> = a list of control parameters to be passed to the reversed graph embedding function - default is NULL</li> </ul> <p>Let's start with the pre-processing step:</p> <pre><code># preprocess_cds does both 1) normalization and 2) preliminary dimension reduction.  By default 1) gene expression count for each cell is divided by the total counts of that cell, multiplied by a scale factor, and log-transformed. This is done  to address differences in sequencing depths for different cells. 2) PCA is used to calculate a lower dimensional space that will be used as the input for downstream steps like UMAP visualization. \ncds &lt;- preprocess_cds(cds, num_dim = 30) # look at the percentage of variance explained by our principal components\nplot_pc_variance_explained(cds)\n</code></pre> <p></p> <p>Here we see that the first few PCA components account for about half the variance. Note that adding components helps with explaining the variation in your data, but comes at the cost of increased computational time. Given this is a subsampled data set, this is less of a concern. Now, let's run the reduce dimentions step!</p> <pre><code># Note here we are using the results of PCA dimension reduction in the last step and visualizing the results in 2 dimensions.\n# umap.fast_sgd=FALSE and cores = 1 are needed for reproducible results \ncds &lt;- reduce_dimension(cds,\npreprocess_method = 'PCA',\numap.fast_sgd=FALSE, cores = 1)\n# let's take another look at our cell data set object\ncds\n</code></pre> <p>output</p> <pre><code>class: cell_data_set \ndim: 12962 4000 \nmetadata(2): cds_version citations\nassays(1): counts\nrownames(12962): FO538757.2 AP006222.2 ... AC004556.1 AC240274.1\nrowData names(1): gene_short_name\ncolnames(4000): 1_AAAGGTACACAGCTGC 1_AAAGGTATCTGCCTGT ...\n6_TTTGACTGTACCATAC 6_TTTGGTTGTTACGTAC\ncolData names(4): treat dataset CellType Size_Factor\nreducedDimNames(2): PCA UMAP\naltExpNames(0)\n</code></pre> <p>Here we would like to highlight that after running our pipeline, we now have two <code>reducedDimNames</code> slots in our object! We can access them with the <code>reducedDims</code> function:</p> <pre><code># let's examine our new `reducedDimNames` slot!\nhead(reducedDims(cds)$UMAP)\n</code></pre> <p>output</p> <pre><code>                        [,1]        [,2]\n1_AAAGGTACACAGCTGC -4.371685 -1.90491864\n1_AAAGGTATCTGCCTGT -9.110986  1.60710314\n1_AACAACCCACACTGGC -8.257574 -0.05704084\n1_AACAAGATCGAAGCAG -6.810462  2.03861049\n1_AACAGGGAGGACAGCT -9.367511  1.91848877\n1_AACCTGAGTATACGGG -9.553589  0.20396432\n</code></pre> <p>To understand why we only ran through the first three steps, we should examine how our cells are distributed in our dimension reduced UMAP plot:</p> <pre><code># view the cell types in our UMAP plot\nplot_cells(cds,\ncolor_cells_by = \"CellType\", show_trajectory_graph = FALSE,\ngroup_label_size = 3,\ncell_size = 0.5)\n</code></pre> <p></p> <p>Grouping cells into clusters is an important step in identifying the cell types represented in your data. Monocle uses a technique called community detection to group cells into cluster and partitions.</p> <pre><code># Grouping cells into clusters is an important step in identifying the cell types represented in your data. Monocle uses a technique called community detection to group cells into cluster and partitions.\ncds &lt;- cluster_cells(cds, k = 20,\npartition_qval = 0.05)\n\nplot_cells(cds,\ncolor_cells_by = \"partition\", show_trajectory_graph = FALSE,\ngroup_label_size = 3,\ncell_size = 0.5)\n</code></pre> <p></p>"},{"location":"trajectoryAnalysis/02_monocle_setup_and_trajectory_analysis/#subsetting-our-data","title":"Subsetting Our Data","text":"<p>Above we can see that we have multiple clusters (usually representing our cells) and multiple partitions (usually representing groups of different cells). When Monocle3 calculates it's trajectory it will typically do so through one of these partitions. So we will subset our data to just grab the partition that contains the Cycling Progenitors, Newborn PNs, and Newborn DL PNs. By doing this we can assess how gene expression changes during cell differentiation from a Cycling Progenitors to a Newborn DL PN:</p> <pre><code># when we examine a trajectory in monocle3 it is useful to look at one\n# partition as you are examining how gene expression changes between clusters\n# in some group\ncds_2 = choose_cells(cds)\n</code></pre> <p>When we go to subset our cells we will choose the following cells:</p> <p></p> <p>Now that we subset our cells, let's examine how our UMAP has changed!</p> <pre><code># check the subset of cells\nplot_cells(cds_2, color_cells_by = \"partition\",\nshow_trajectory_graph = FALSE,\ngroup_label_size = 3,\ncell_size = 0.5)\n</code></pre> <p></p>"},{"location":"trajectoryAnalysis/02_monocle_setup_and_trajectory_analysis/#trajectory-analysis","title":"Trajectory Analysis","text":"<p>Now that we have subsampled cells moving from Cycling Progenitors to Newborn DL PNs, we will need to re-run the Monocle3 workflow on our data given that our clustering was done on the larger data set.</p> <pre><code># re-run the monocle3 workflow on our subset data:\n# use the same # of top PCs as used for clustering\ncds_2 &lt;- preprocess_cds(cds_2, num_dim = 20)\n\n# take another look at the variance explained \nplot_pc_variance_explained(cds_2)\n</code></pre> <p></p> <p>You'll note again that the first few PCA components explain about half the variance. Here we include fewer PCA components to account for the variance as we reduced the number the of total cells we are examining. We can now move on and apply the reduce_dimensions/cluster_cells functions to our data:</p> <pre><code># reduce the dimensions \ncds_2 &lt;- reduce_dimension(cds_2,\npreprocess_method = 'PCA',\numap.fast_sgd=FALSE, cores = 1)\n\n# force few partitions with partition q-value set higher\ncds_2 &lt;- cluster_cells(cds_2, k = 20,\npartition_qval = 1)\n\n# do we only have one partition now?\nplot_cells(cds_2,\ncolor_cells_by = \"partition\", show_trajectory_graph = FALSE,\ngroup_label_size = 3,\ncell_size = 0.5)\n</code></pre> <p></p> <p>Note that in the above plot that all of our cells are now in one partition. This time we will calculate trajectories in our data now that we have a subset of cells in which it makes sense to do so. You will note that we specify two options when we \"learn our graph\". One being 'use_partition = FALSE' which we will not use as we have already subset our cell population. The other being 'close_loop = TRUE', which we specify as this allows for the trajectory to form loops. This is important if we want to to identify populations of cells with cyclic behavior.</p> <pre><code># additionally we will run learn_graph to calculate trajectories on our subset!\ncds_2 &lt;- learn_graph(cds_2,\nuse_partition = FALSE,\nclose_loop = TRUE)\n\n# now that we have subset out data, re-run our monocle workflow, and calculated \n# trajectories, let's see where we should set our root node!\nplot_cells(cds_2, color_cells_by = \"CellType\",\ncell_size = 0.5,\nlabels_per_group = 0) </code></pre> <p></p> <p>We can see that we have a trajectory now connecting the Cylcing Progenitor cells and the Newborn DL PNs!</p>"},{"location":"trajectoryAnalysis/03_pseudotime_and_differential_expression/","title":"Pseudotime and Differential Expression","text":""},{"location":"trajectoryAnalysis/03_pseudotime_and_differential_expression/#pseudotime-and-differential-expression","title":"Pseudotime and Differential Expression","text":""},{"location":"trajectoryAnalysis/03_pseudotime_and_differential_expression/#pseudotime","title":"Pseudotime","text":"<p>Monocle introduced the concept of pseudotime which they define as: \"Pseudotime is a measure of how much progress an individual cell has made through a process such as cell differentiation.\" We will assess \"progress\" by a cell's differentiation status. So we will manually chose the starting point to be the cycling progenitors: </p> <pre><code># monocle introduced the concept of pseudotime which they define as:\n# \"Pseudotime is a measure of how much progress an individual cell has made \n# through a process such as cell differentiation.\"\n# we will assess \"progress\" by a cell's differentiation status. So we will\n# manually chose the starting point to be the cycling progenitors\ncds_2 = order_cells(cds_2) </code></pre> <p></p> <p>Now let's visualize pseudotime in our UMAP plot to understand what is early pseudotime (low values - dark purple) and late pseudotime (high values - yellow):</p> <pre><code># plot pseudo time after choosing root nodes \n# (defined as the bottom in the cycling progenitors cell type)\nplot_cells(cds_2,\nshow_trajectory_graph = T,\ncolor_cells_by = \"pseudotime\",\ngraph_label_size=3,\ncell_size = 0.5) </code></pre> <p></p>"},{"location":"trajectoryAnalysis/03_pseudotime_and_differential_expression/#distribution-of-wild-type-and-mutant-cells","title":"Distribution of Wild-Type and Mutant Cells","text":"<p>Paulson et al. 2022 note that there is a difference in the distribution of Wild-Type and Mutant Cells within this UMAP. Let's try coloring our UMAP plot by the treatment (Wild-Type v. Mutant Cells):</p> <pre><code># how are our wild-type and mutant cells distributed in this graph?\nplot_cells(cds_2, color_cells_by = \"treat\", show_trajectory_graph = F, label_cell_groups = F,\ncell_size = 0.5) </code></pre> <p></p> <p>Optional: Pseudotime Ridgeplot View</p> <p>This view can be a bit busy, we can better see the distribution of the number of cells in each condition through pseudotime with a ridge plot like in the paper!</p> <pre><code># isolate meta data\ncds_meta = colData(cds_2)\n\n# add pseudo-time to meta data\ncds_meta$pseudotime = pseudotime(cds_2)\n\n# filter data for where pseudo time is finite\ncds_meta = cds_meta[is.finite(cds_meta$pseudotime),]\n\n# plot pseudo-time for cells that assessed for pseudo-time\nggplot(as.data.frame(cds_meta), aes(x=pseudotime,\ny=treat)) + ggridges::geom_density_ridges(aes(fill=treat))  </code></pre> <p></p> <p>Here we can see that there is a spike in the number of cells in the mutant population at later pseudotime values. </p>"},{"location":"trajectoryAnalysis/03_pseudotime_and_differential_expression/#differential-expression","title":"Differential Expression","text":"<p>We will now create a model to to assess how genes vary with pseudotime and treatment. However, before we do that we need to factor our variables of interest!</p> <pre><code># create pseudotime bins for visualization later\ncds_meta$pseudotime_bins &lt;- as.numeric(\n  cut_number(\n    cds_meta$pseudotime,\n    6))\n\n# factor our treatment variable\ncds_meta$treat &lt;- factor(cds_meta$treat, levels=c(\"wt\",\"mut\"))\n\n# swap our meta data back into the cell data set object\ncolData(cds_2) &lt;- cds_meta\n</code></pre> <p>Let's run our model to assess genes that vary due to pseudotime and treatment. We then print the column names and the dimensions of the results data frame. Just note that this will take a bit of time to run!</p> <pre><code># create a model to assess how genes vary with predictors: pseudotime and treatment \ngene_fits &lt;- fit_models(cds_2, \n                        model_formula_str = \"~ pseudotime + treat\",\n                        cores = 1)\n\n# grab the coefficients table\nfit_coefs &lt;- coefficient_table(gene_fits)\n\ncolnames(fit_coefs)\ndim(fit_coefs)\n</code></pre> <p>output</p> <pre><code>[1] 38886    14\n</code></pre> <p>Here you will notice that we have 14 columns pertaining to model information and 38886 rows corresponding to terms in those models.</p>"},{"location":"trajectoryAnalysis/03_pseudotime_and_differential_expression/#filter-for-significant-genes","title":"Filter For Significant Genes","text":"<p>Now that we have a data frame with our model results, we can subset it to grab the columns/rows we need. One popular package to do just this in R is dplyr. Let's use dplyr to select the columns we need:</p> <pre><code># now that we have a data frame with our model results, we can subset it to grab\n# the columns/rows we need. One popular package to do just this in R is dplyr\n# Let's use dplyr to select the columns we need:\nfit_coef_filter &lt;- fit_coefs %&gt;% \n  dplyr::select(c(gene_short_name, term, status, estimate, std_err, p_value, q_value))\n\ndim(fit_coef_filter)\n</code></pre> <p>output</p> <pre><code>[1] 38886     7\n</code></pre> <p>You'll note that we now only have 7 columns!</p> <pre><code># we can also use dplyr to filter the rows we need\n# let's use the filter function to remove lines that correspond to the\n# intercept and for genes where the q-value is less than 0.05:\nfit_coef_filter &lt;- fit_coef_filter %&gt;%\n  dplyr:: filter(term != \"(Intercept)\" &amp; q_value&lt;0.05) \n\ndim(fit_coef_filter)\n</code></pre> <p>output</p> <pre><code>[1] 3964    7\n</code></pre> <p>You'll note that we only have 3964 genes!</p> <pre><code># view our results data frame to and sort genes by q-value for \n# both genes that vary due to pseudotime and the treatment\nview(fit_coef_filter)\n</code></pre>"},{"location":"trajectoryAnalysis/03_pseudotime_and_differential_expression/#plot-genes-that-vary-over-pseudotimetreatment","title":"Plot Genes That Vary Over Pseudotime/Treatment","text":"<pre><code># example of genes that vary over pseudotime \n# NOTE: After plotting RTN1, try plotting another gene!\ncds_subset &lt;- cds_2[rownames(cds_2) %in% c(\"RTN1\"),]\n\n# plot genes that vary over pseudotime\nplot_genes_violin(cds_subset, \n                  group_cells_by=\"pseudotime_bins\",\n                  ncol=2) +  \n  theme(axis.text.x=element_text(angle=45, hjust=1))\n</code></pre> <p>output</p> <p></p> <p>Here you can see that as pseudotime increases so does the expression of RTN1. Let's try out a gene that varies due to the treatment effect:</p> <pre><code># example of genes that vary as a result of the treatment\n# NOTE: After plotting MT-ND3, try plotting another gene!\ncds_subset &lt;- cds_2[rownames(cds_2) %in% c(\"MT-ND3\"),]\n\n# plot genes that vary as a result of the treatment\nplot_genes_violin(cds_subset, \n                  group_cells_by=\"treat\",\n                  label_by_short_name = F) +\n  theme(axis.text.x=element_text(angle=45, hjust=1))\n</code></pre> <p>output</p> <p></p> <p>Here you'll notice that MT-ND3 is slightly upregulated in the Wild-Type when compared to the Mutant! </p>"},{"location":"trajectoryAnalysis/0X_seurat_manipulation/","title":"0X seurat manipulation","text":"<p>Seurat is a user friendly R package used to analyze single-cell RNA-Seq data. Seurat objects have the following structure:</p> <p>Seurat Objects</p> <p></p> <p>Let's invetstigate some single cell data - first we will need to load the necessary libraries:</p> <pre><code># --- Load Libraries -----------------------------------------------------------\nLIB='/cluster/tufts/hpc/tools/R/4.0.0/'\n.libPaths(c(\"\",LIB))\n.libPaths()\nlibrary(Seurat)\nlibrary(monocle3)\nlibrary(clusterProfiler)\nlibrary(patchwork)\nlibrary(tidyverse)\n\n# --- Load Data ----------------------------------------------------------------\n\n# start with the day 35 seurat object \nseur &lt;- readRDS(\"./results/asd_organoids/suv420h1_mito210_d35_sub.rds\")\n</code></pre> <p>Now let's see what is in our Seurat object and how we can access our data:</p> <pre><code># --- Explain the Seurat Object ------------------------------------------------\n\n# what is in this Seurat Object?\nseur\n\n# gene names\nrownames(seur)\n\n# cell names\ncolnames(seur)\n\n# what assays do I have?\nSeurat::Assays(seur)\n\n# how do I access these assays?\nGetAssayData(object = seur, assay = \"RNA\",\nslot = \"counts\")\n\n# how do I switch the default assay to be used?\nDefaultAssay(seur) &lt;- \"RNA\"\n\n# how do I access the meta data?\nhead(seur@meta.data)\n\n# how can I access the dimension reductions?\nEmbeddings(object = seur, reduction = \"pca\")\nEmbeddings(object = seur, reduction = \"umap\")\n\n# How can I visualize my clustering?\nDimPlot(object = seur,\nreduction = \"umap\")\n\n# what are the identities?\nIdents(object = seur)\n\n# how can I change the identities to the cell type?\nIdents(object = seur) &lt;- seur$CellType\n\n# how can I see if this changed the identities?\nDimPlot(object = seur,\nreduction = \"umap\")\n\n# meta data in umap\nFeaturePlot(object = seur,\nreduction = \"umap\",\nfeatures =c(\"percent.mito\",\"percent.ribo\"))\n\n# genes in umap\nFeaturePlot(object = seur,\nreduction = \"umap\",\nfeatures =\"TOP2A\")\n</code></pre>"}]}